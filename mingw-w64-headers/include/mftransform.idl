/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the mingw-w64 runtime package.
 * No warranty is given; refer to the file DISCLAIMER.PD within this package.
 */

import "mfobjects.idl";

cpp_quote("  enum _MFT_DRAIN_TYPE {")
cpp_quote("    MFT_DRAIN_PRODUCE_TAILS   = 0x00000000,")
cpp_quote("    MFT_DRAIN_NO_TAILS        = 0x00000001 ")
cpp_quote("  };")
cpp_quote("")
cpp_quote("  enum _MFT_INPUT_STATUS_FLAGS {")
cpp_quote("    MFT_INPUT_STATUS_ACCEPT_DATA   = 0x00000001 ")
cpp_quote("  };")
cpp_quote("")
cpp_quote("  enum _MFT_INPUT_DATA_BUFFER_FLAGS {")
cpp_quote("    MFT_INPUT_DATA_BUFFER_PLACEHOLDER   = 0xFFFFFFFF ")
cpp_quote("  };")
cpp_quote("")
cpp_quote("  enum _MFT_OUTPUT_STREAM_INFO_FLAGS {")
cpp_quote("    MFT_OUTPUT_STREAM_WHOLE_SAMPLES              = 0x00000001,")
cpp_quote("    MFT_OUTPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER   = 0x00000002,")
cpp_quote("    MFT_OUTPUT_STREAM_FIXED_SAMPLE_SIZE          = 0x00000004,")
cpp_quote("    MFT_OUTPUT_STREAM_DISCARDABLE                = 0x00000008,")
cpp_quote("    MFT_OUTPUT_STREAM_OPTIONAL                   = 0x00000010,")
cpp_quote("    MFT_OUTPUT_STREAM_PROVIDES_SAMPLES           = 0x00000100,")
cpp_quote("    MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES        = 0x00000200,")
cpp_quote("    MFT_OUTPUT_STREAM_LAZY_READ                  = 0x00000400,")
cpp_quote("    MFT_OUTPUT_STREAM_REMOVABLE                  = 0x00000800 ")
cpp_quote("  };")
cpp_quote("")
cpp_quote("  enum _MFT_OUTPUT_STATUS_FLAGS {")
cpp_quote("    MFT_OUTPUT_STATUS_SAMPLE_READY   = 0x00000001 ")
cpp_quote("  };")
cpp_quote("")
cpp_quote("  enum _MFT_OUTPUT_DATA_BUFFER_FLAGS {")
cpp_quote("    MFT_OUTPUT_DATA_BUFFER_INCOMPLETE      = 0x01000000,")
cpp_quote("    MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE   = 0x00000100,")
cpp_quote("    MFT_OUTPUT_DATA_BUFFER_STREAM_END      = 0x00000200,")
cpp_quote("    MFT_OUTPUT_DATA_BUFFER_NO_SAMPLE       = 0x00000300 ")
cpp_quote("  };")
cpp_quote("")
cpp_quote("  enum _MFT_INPUT_STREAM_INFO_FLAGS {")
cpp_quote("    MFT_INPUT_STREAM_WHOLE_SAMPLES              = 0x00000001,")
cpp_quote("    MFT_INPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER   = 0x00000002,")
cpp_quote("    MFT_INPUT_STREAM_FIXED_SAMPLE_SIZE          = 0x00000004,")
cpp_quote("    MFT_INPUT_STREAM_HOLDS_BUFFERS              = 0x00000008,")
cpp_quote("    MFT_INPUT_STREAM_DOES_NOT_ADDREF            = 0x00000100,")
cpp_quote("    MFT_INPUT_STREAM_REMOVABLE                  = 0x00000200,")
cpp_quote("    MFT_INPUT_STREAM_OPTIONAL                   = 0x00000400,")
cpp_quote("    MFT_INPUT_STREAM_PROCESSES_IN_PLACE         = 0x00000800 ")
cpp_quote("  };")
cpp_quote("")
cpp_quote("  typedef enum _VSS_HARDWARE_OPTIONS {")
cpp_quote("    VSS_BREAKEX_FLAG_MASK_LUNS                      = 0x00000001,")
cpp_quote("    VSS_BREAKEX_FLAG_MAKE_READ_WRITE                = 0x00000002,")
cpp_quote("    VSS_BREAKEX_FLAG_REVERT_IDENTITY_ALL            = 0x00000004,")
cpp_quote("    VSS_BREAKEX_FLAG_REVERT_IDENTITY_NONE           = 0x00000008,")
cpp_quote("    VSS_ONLUNSTATECHANGE_NOTIFY_READ_WRITE          = 0x00000100,")
cpp_quote("    VSS_ONLUNSTATECHANGE_NOTIFY_LUN_PRE_RECOVERY    = 0x00000200,")
cpp_quote("    VSS_ONLUNSTATECHANGE_NOTIFY_LUN_POST_RECOVERY   = 0x00000400,")
cpp_quote("    VSS_ONLUNSTATECHANGE_DO_MASK_LUNS               = 0x00000800 ")
cpp_quote("  } VSS_HARDWARE_OPTIONS, *PVSS_HARDWARE_OPTIONS;")

enum _MFT_SET_TYPE_FLAGS {
    MFT_SET_TYPE_TEST_ONLY   = 0x00000001
};

enum _MFT_PROCESS_OUTPUT_STATUS {
    MFT_PROCESS_OUTPUT_STATUS_NEW_STREAMS   = 0x00000100
};

enum _MFT_PROCESS_OUTPUT_FLAGS {
    MFT_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER   = 0x00000001
};

typedef enum _MFT_MESSAGE_TYPE {
    MFT_MESSAGE_COMMAND_FLUSH            = 0x00000000,
    MFT_MESSAGE_COMMAND_DRAIN            = 0x00000001,
    MFT_MESSAGE_SET_D3D_MANAGER          = 0x00000002,
    MFT_MESSAGE_NOTIFY_BEGIN_STREAMING   = 0x10000000,
    MFT_MESSAGE_NOTIFY_END_STREAMING     = 0x10000001,
    MFT_MESSAGE_NOTIFY_END_OF_STREAM     = 0x10000002,
    MFT_MESSAGE_NOTIFY_START_OF_STREAM   = 0x10000003,
    MFT_MESSAGE_COMMAND_MARKER           = 0x20000000
} MFT_MESSAGE_TYPE;

typedef struct _MFT_INPUT_STREAM_INFO {
    LONGLONG hnsMaxLatency;
    DWORD    dwFlags;
    DWORD    cbSize;
    DWORD    cbMaxLookahead;
    DWORD    cbAlignment;
} MFT_INPUT_STREAM_INFO;

typedef struct _MFT_OUTPUT_STREAM_INFO {
    DWORD dwFlags;
    DWORD cbSize;
    DWORD cbAlignment;
} MFT_OUTPUT_STREAM_INFO;

typedef struct _MFT_OUTPUT_DATA_BUFFER {
    DWORD         dwStreamID;
    IMFSample     *pSample;
    DWORD         dwStatus;
    IMFCollection *pEvents;
} MFT_OUTPUT_DATA_BUFFER;

[
    object,
    uuid(bf94c121-5b05-4e6f-8000-ba598961414d)
]
interface IMFTransform : IUnknown
{
    HRESULT GetStreamLimits([out] DWORD *pdwInputMinimum, [out] DWORD *pdwInputMaximum,
            [out] DWORD *pdwOutputMinimum, [out] DWORD *pdwOutputMaximum);
    HRESULT GetStreamCount([out] DWORD *pcInputStreams, [out] DWORD *pcOutputStreams);
    HRESULT GetStreamIDs(DWORD dwInputIDArraySize, [out,size_is(dwInputIDArraySize)] DWORD *pdwInputIDs,
            DWORD dwOutputIDArraySize, [out,size_is(dwOutputIDArraySize)] DWORD *pdwOutputIDs);
    HRESULT GetInputStreamInfo(DWORD dwInputStreamID, [out] MFT_INPUT_STREAM_INFO *pStreamInfo);
    HRESULT GetOutputStreamInfo(DWORD dwOutputStreamID, [out] MFT_OUTPUT_STREAM_INFO *pStreamInfo);
    HRESULT GetAttributes([out] IMFAttributes **pAttributes);
    HRESULT GetInputStreamAttributes(DWORD dwInputStreamID, [out] IMFAttributes **pAttributes);
    HRESULT GetOutputStreamAttributes(DWORD dwOutputStreamID, [out] IMFAttributes **pAttributes);
    HRESULT DeleteInputStream(DWORD dwStreamID);
    HRESULT AddInputStreams(DWORD cStreams, [in] DWORD *adwStreamIDs);
    HRESULT GetInputAvailableType(DWORD dwInputStreamID, DWORD dwTypeIndex, [out] IMFMediaType **ppType);
    HRESULT GetOutputAvailableType(DWORD dwOutputStreamID, DWORD dwTypeIndex, [out] IMFMediaType **ppType);
    HRESULT SetInputType(DWORD dwInputStreamID, [in]  IMFMediaType *pType, DWORD dwFlags);
    HRESULT SetOutputType(DWORD dwOutputStreamID, [in] IMFMediaType *pType, DWORD dwFlags);
    HRESULT GetInputCurrentType(DWORD dwInputStreamID, [out] IMFMediaType **ppType);
    HRESULT GetOutputCurrentType(DWORD dwOutputStreamID, [out] IMFMediaType **ppType);
    HRESULT GetInputStatus(DWORD dwInputStreamID, [out] DWORD *pdwFlags);
    HRESULT GetOutputStatus([out] DWORD *pdwFlags);
    HRESULT SetOutputBounds(LONGLONG hnsLowerBound, LONGLONG hnsUpperBound);
    HRESULT ProcessEvent(DWORD dwInputStreamID, [in] IMFMediaEvent *pEvent);
    HRESULT ProcessMessage(MFT_MESSAGE_TYPE eMessage, ULONG_PTR ulParam);
    [local] HRESULT ProcessInput(DWORD dwInputStreamID, IMFSample *pSample, DWORD dwFlags);
    [local] HRESULT ProcessOutput(DWORD dwFlags, DWORD cOutputBufferCount,
                                  [in,out,size_is(cOutputBufferCount)] MFT_OUTPUT_DATA_BUFFER *pOutputSamples,
                                  [out] DWORD *pdwStatus);
}

cpp_quote("#if (WINVER >= 0x0601)")
cpp_quote("HRESULT WINAPI MFCreateTransformActivate(IMFActivate **ppActivate);")
cpp_quote("#endif /*(WINVER >= 0x0601)*/")
